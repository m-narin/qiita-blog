---
title: study4_bit
tags:
  - Python
  - 初心者
  - 競技プログラミング
  - 新人プログラマ応援
private: false
updated_at: ''
id: null
organization_url_name: null
slide: false
ignorePublish: false
---
## はじめに
新卒エンジニア同士で実施している勉強会の第4回目の記事になります。
今回のテーマはbit演算についてです。

<!-- TODO: 記事リンク貼る -->
| 回     | テーマ | 記事リンク |
|:-----------|:------------|:------------|
| 第1️回      | 二分探索      | <coming soon>    |
| 第2回      | ソートアルゴリズム  |  <coming soon>     |
| 第3回      | 暗号化            |  <coming soon>     |
| **第4回**  | **bit演算**      |  <coming soon>    |
| 第5回      | 連想配列          | <coming soon>   |
| 第6回      | グラフ理論        |  <coming soon>   |

## 前提
今回はbit演算を用いて簡単な計算をするプログラムを作ります。私たちがコンピュータを触る際は、当たり前のように足し算引き算掛け算割り算の命令を入力すると計算が返ってきますね。しかしコンピュータは根源的には物理的な電気信号のon, offという二つの情報しか扱っていません。四則演算をどのように実現しているのか？を考えるのが今回の目的です！
問題に取り掛かる前に、知っておきたい概念があるためその説明から入ります。

### 電気回路
コンピュータは全ての情報を電圧の高い(5v)、低い(0v)という二種類のデジタル信号のみで表しています。電気信号は回路とスイッチを使うことで流れを制御することができます。

![kairo.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/545ab640-9fd0-5082-c7e4-65f287821fce.png)

いずれの図も左側が高電圧で右の方に電流が流れているものと捉えてください。山から川が上流→下流に流れているようなイメージです。
そこに何らかの操作でスイッチをonにすることを考えます。操作とは、たとえばCtrl(command)キーと「c」を同時に入力するとコピー処理が動くといった状況です。

一番上の図は直列回路を表します。一本の線で繋がっているため両方のスイッチがonにならないと他方に電流は流れません。これはAND回路とも言います。これはまさにCtrl(command)キーと「c」を同時に入力するとコピー処理が動く状況と対応していますね。
真ん中の図は並列回路を表します。分岐があるため少なくとも一方のスイッチがonになっていれば電流は他方に流れます。これはOR回路とも言います。
一番下の図はNOT回路です。これは高い電圧が流れてきた時は低い電圧を出力し、低い電圧が流れてきた時は高い電圧を出力します。つまり電圧の高低を反転させる働きを持ちます。内部的には下記図のよう上から常に電流を流しておいて入力がある場合は電磁石の要領でスイッチがonになるような仕組みとなっています。スイッチがonになると上から下に電流が流れるので出力に電流は流れません。逆に入力がない場合はスイッチがoffとなっていて、上からの電流は出力側に流れていきます。

![not_kairo.jpeg](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/5cb953fd-dbe6-02a8-1549-71f0b3b996ec.jpeg)


この三つの回路のパターンが基本原理となります。これらを色々組み合わせることで様々な電流の流れのパターンを作り出すことができます。
様々な電流の流れのパターンは記号で規格化されています。それらをまとめると以下図のようになります。

![kairo_matome.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/dfef04d2-21c1-b464-85b4-37ec49a797ce.png)

たとえば、片方の入力のみがある場合に出力するような回路をXOR回路と言います。XORに関して上図の記号とベン図を見てみます。まずA以外の領域かつBに重なる場所は、右側の、中央の重なりの除いたBの領域になります。反対にB以外の領域かつAと重なる場所は、左側の、中央の重なりを除いたAの領域になります。つまり、A入力の反転(NOT)とB入力のAND回路、B入力の反転(NOT)とA入力のAND回路を作り、この二つの出力をOR回路に繋げば良いというわけですね。

これは下記図のようにNOT, AND, OR回路を配置することで実現できます。

![xor.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/0a4d9225-2651-cd69-db39-3cc832aa4af0.png)

### bit演算

### 2進法とは？


## 問題
1桁の2進数の数字2つが以下のように与えられます。

```shell:input
1,0
```
入力された二つの数字の和に関して、繰り上がり部分と一桁目を出力してください。

なお、以下の条件に従ってください。
- bit演算子を使うこと
- 計算量は問いません

### テストケース
```shell:input1
901
5
836
```

```shell:output1
777
```

```shell:input2
2773
17
1647
```

```shell:output2
2024
```

```shell:input3
23763750720320755089986836889386752333148454401954967562246067964867289138953959780717079688179130465650799885381128444602378117801374965735319583220896780571277261256156846877426142522785396049700319360493746460388891291877334647769138315576265478137249565382290203874694134519392957422540203022062882075405911121664718704644321479425687111651838911360686725629604293945223524169767648631213310792471748148155314286839441622349839299969847466395263222429344465646709824625925965427682282530676386023451803005481500038573372924827423756149573698159403684701896723624641100816859773212094543180200907204545388240139873
65537
8415193396543311353484421939238676093551842164971427185704097190178024351893340295680735321393780311840244869986682879096195012272166629614593460647812271305235527777754835140274392570370347880248411379950593107597810919502273451084589323176477491051476512881744527931527774798075893681139907243050509632488215183600512761950585193887831590494038281760727275445162394107244799292585041038475269525888152844146387779398177114276753330862352263395304480337880761057765477558514448524077641571808843866618899695005802755036106106076084395503279687316594954590030543862355124606471965783095127625163775336406697681524837
```

```shell:output3
893
```

### コマンドラインからの入力を受け取る方法

```py:python
# 入力
n = int(input())
e = int(input())
c = int(input())
```

### 解答例

<details><summary>クリックすると解答例が見られます</summary>

```py:
# 入力
n = int(input())
e = int(input())
c = int(input())

def decrypt_rsa(n, e, c):
    # pとqを見つける（素因数分解。一つでも素数が見つかれば、自動的にもう片方も一つに定まる）
    p, q = None, None
    for i in range(2, n):
        if n % i == 0:
            p = i
            q = n // i
            break

    if not p or not q:
        return "pとqが見つかりませんでした。"

    # dを見つける
    phi = (p - 1) * (q - 1)
    d = None
    for i in range(1, phi):
        if (i * e) % phi == 1:
            d = i
            break

    if not d:
        return "dが見つかりませんでした。"

    # 暗号文cを復号する
    M = None
    for _ in range(d):
        M = (c ** d) % n

    return M

# 復号されたパスワードを計算
decrypted = decrypt_rsa(n, e, c)

print(decrypted)
```
繰り返し処理を用いて、それぞれの指示に従ったプログラムを書きます。
テストケースは3つありますが、3つとも解読できたでしょうか？

3つ目の暗号はtimeoutになるはずです。これが解けたら世界のセキュリティが崩壊します。。。

</details>

## 解説
RSA暗号は公開鍵暗号方式の一種となります。
なんとなく、公開鍵、秘密鍵という単語は聞いたことのある方も多いとは思いますが、上で見たように数式によって成立しているんですね。

:::note warn
上記の数式でなぜ元の文が復号できるのかの理論的な背景はこちらの記事に詳しいです。(数学の証明になります)
https://qiita.com/reika727/items/215d23bf18e21e3cbc52
:::

攻撃者の視点に立てば、pとqが分かれば暗号を解読することができます。
しかし、3つ目のテストケースは、617桁の途方もなく大きい数字(ちなみに無量大数は68桁)なので、素因数分解のプログラムがtimeoutしてしまいます。
実際にこれくらいのサイズの公開鍵がSSL等で利用されています。
また現代では、素因数分解のアルゴリズムはしらみ潰しに調べるO(n)の方法しか見つかっていません。

つまり、巨大な数字の素因数分解の困難さによってRSA暗号のセキュリティが保証されているのです。これをRSA仮定と言います。

RSA暗号は、あくまで現代の技術では解読できないという前提のもと成立している暗号化技術です。もし将来的に量子コンピュータの発展や、新たな素数の法則、新たな素因数分解のアルゴリズムが見つかってしまえば、現代のセキュリティが崩壊してしまう恐れがあることも理解しておく必要があります。

改めて、順を追ってRSA暗号の暗号化と復号化を見ていきましょう。

### step1 公開鍵(n,e)を用意する

まずサーバー側の立場に立って公開鍵を作ります。
1. 互いに素なp,qを任意に選びます。「互いに素」は、共通の約数が1以外に存在しない数字のペアを意味します。
2. n = pqとします。
3. (p - 1) * (q - 1)と互いに素な自然数eを任意に選びます。
4. e * dを(p - 1) * (q - 1)で割った余りが1となる自然数dを任意に選びます。

例えば以下のような数字を選びます。(簡単のため小さい数字を使います。)
1. p = 7、q = 5とする。
2. n = 7 * 5 = 35となる。
3. (p - 1) * (q - 1) = 6 * ４ = 24となるので、e ＝ 11とする。
4. 11 * dを24で割った余りが1となるdを探し、d = 83とする。(913 ÷ 24 = 38...あまり1)

このn = 35, e = 11を公開鍵として公開します。
p = 7, q = 5, d = 83は秘密鍵となります。

### step2 元の文を暗号化する
次にユーザーの立場に立って、公開鍵を利用して元の文を暗号化します。

1. 元の文mをe乗をnで割った余りが暗号文cとなります。

具体的に元の文m = 12として計算してみます。
1. c = 12の11乗を35で割った余り = 3

よって暗号文c = 3がサーバー側に送信されます。

### step3 暗号文を復号する
受信者であるサーバー側の視点に立って、暗号文を復号します。

1. cのd乗をnで割った余りが元の文となります。

具体的に、当てはめて計算してみます。
1. 3の83乗を35で割ったあまり = 12

このように復号することができました。

今までの流れを図示すると以下のようになります。

![スクリーンショット 2024-01-01 1.27.11.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/1023910a-c923-20db-797c-2ef303366b4f.png)

n=pqが途方もなく大きいおかげで、攻撃者から通信を保護することができるというわけですね✨

## おわりに
勉強会第3回の内容として、暗号化をテーマに学びました。

普段利用するhttps(ssl)やsshも、RSA暗号のような暗号化技術が基になってプロトコルが制定されています。
なんとなく聞いたことのある公開鍵や秘密鍵の正体がこの記事を通して理解できたと思います。
また一つ、教養が深まりましたね🙌

<!-- TODO: 記事リンク貼る -->
次回の勉強会はbit演算についてです。

