---
title: 新卒エンジニア勉強会-グラフ理論
tags:
  - Python
  - 初心者
  - 競技プログラミング
  - 新人プログラマ応援
private: false
updated_at: ''
id: null
organization_url_name: null
slide: false
ignorePublish: false
---

## はじめに
新卒エンジニア同士で実施している勉強会の第6回目の記事になります。
今回のテーマはグラフ理論についてです。

<!-- TODO: 記事リンク貼る -->
| 回     | テーマ | 記事リンク |
|:-----------|:------------|:------------|
| 第1️回      | 二分探索      | <coming soon>    |
| 第2回      | ソートアルゴリズム  |  <coming soon>     |
| 第3回      | 暗号化           |  <coming soon>     |
| 第4回      | bit演算          |  <coming soon>    |
| 第5回      | 連想配列      | <coming soon>   |
| **第6回**  | **グラフ理論**   |  <coming soon>   |

## 前提
グラフ理論とはネットワークや組織、経路のようなグラフ構造を扱うための学問です。

![graph.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/394dc9a0-55a4-38c4-8f27-a3be3eb4d42b.png)

グラフ構造は、ノード(点)とエッジ(線)から成るデータ構造です。ある頂点に何本の線が繋がっているかを次数と言います。

古くからは数学的なアプローチによる研究が行われてきました。
起源は、オイラーという数学者がケーニヒスベルクにかかる7つの橋を全て渡って元に戻ってこられるか、という問題を解くことから始まりました。これは一筆書きと同じ意味を指します。

![river.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/32cafc43-ff1a-7104-87bc-69b6b74013e0.png)

![river_graph.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/d685b68b-2ebc-3c2f-fa12-684d54e90329.png)

結論としてこれらの橋は一筆書きできません。一筆書きができる条件は以下のように求められています。

- すべての頂点の次数が偶数
- 次数が奇数である頂点の数が2で、残りの頂点の次数は全て偶数

現代では、コンピュータリソースの発展により大規模なグラフ構造=ネットワークを計算できるようになってきました。世の中には、ネットワーク構造でモデル化できる事柄がたくさんあります。

- 路線図、乗り換え案内
- カーナビ、経路探索
- インターネット、検索
- SNS、フォロー
- ...

これらのネットワークを考察するにあたっては、グラフ構造をコンピュータが計算できるデータ構造として定義する必要があります。点と線、そしてそのつながりをどのように表現できるのかを見ていきましょう。

## 問題1
M頂点、N辺の連結な単純無向グラフが与えられます。なお用語の意味は以下です。
連結=点と点が線で繋がっていること
単純=グラフにループが含まれないこと
無向=線に向きが存在しないこと

自分自身より頂点番号が小さい隣接頂点がちょうど1つ存在する頂点の個数はいくつかを出力してください。

```shell:input
5 6 // M, N
1 2 // 頂点1と頂点2が線で結ばれている。以下同様。
1 3
3 2
5 2
4 2
4 5
```

上記のテストケースは以下ように理解します。
まず、頂点数が5なので5つの点を用意します。

![graph_test1.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/ab6039ab-80c2-3e88-4110-811ced45031a.png)

線の数が6本あるので、6行分の線の情報があります。2行目は頂点1と頂点2が線で結ばれていることを表します。

![graph_test2.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/996d8237-5f0c-c44d-30f2-a847d8dc9e24.png)

以下同様に6行分の線を書くと最終的に以下ようなグラフになります。

![graph_test3.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/614347/d85ffb3e-c19d-5e19-c079-c2cdc272dbcd.png)

「自分自身より頂点番号が小さい隣接頂点がちょうど1つ存在する頂点の個数」を次のように数えます。
まず1の頂点に注目すると、自分より頂点番号が小さいものが存在しないので対象外です。
2の頂点を見ると、繋がっている点として1があるので自分より頂点番号が小さい点が一つだけあることになり題意に当てはまります。
3の頂点を見ると、1,2と繋がっていて自分より小さい点2つと繋がっているので題意に当てはまりません。
4の頂点を見ると、2,5と繋がっていて自分より小さい点が一つだけあるので、題意に当てはまります。
5の頂点を見ると、2,4と繋がっていて自分より小さい点2つと繋がっているので題意に当てはまりません。

結果として題意を満たす頂点は2,4の2つなので回答は2となります。

なお、以下の条件に従ってください。
- テストケースは全て満たすこと
- 組み込みメソッドは使わないこと。つまり、分岐、繰り返し処理を自分で書くこと。
  - Array.findなどは使わない
- 解法を調べるためにchatgpt、インターネットは使用しないこと
  - 文法を調べることのみ可
- 計算量は問いません

### テストケース
```shell:input1
5 6 
1 2 
1 3
3 2
5 2
4 2
4 5
```

```shell:output1
2
```

```shell:input2
2 1
1 2
```

```shell:output2
1
```

```shell:input3
7 18
7 2
1 6
5 2
1 3
7 6
5 3
5 6
5 4
1 7
2 6
3 4
5 1
4 7
4 6
5 7
3 2
4 2
1 4
```

```shell:output3
0
```

### コマンドラインからの入力を受け取る方法

```py:python
# 入力
# M頂点、N辺の数を受け取る
M, N = map(int, input().split())

# N辺分の頂点の結びを受け取る
for i in range(N):
    a, b = map(int,input().split())
```

### 解答例

<details><summary>クリックすると解答例が見られます</summary>

グラフ構造の表現でよく用いられるデータ構造は隣接行列、隣接リストがあります。

隣接行列を用いた方法

```py:
# 入力
M, N = map(int, input().split())

# 隣接行列の初期化
adjacency_matrix = [[0 for _ in range(M)] for _ in range(M)]

for i in range(N):
    a, b = map(int,input().split())
    adjacency_matrix[a-1][b-1] = 1
    adjacency_matrix[b-1][a-1] = 1

count = 0
for i in range(M):
    smaller_neighbors = 0
    for j in range(i):
        if adjacency_matrix[i][j] == 1:
            smaller_neighbors += 1
    if smaller_neighbors == 1:
        count += 1

print(count)
```

```py:テストケース1の隣接行列
[
 [0, 1, 1, 0, 0], 
 [1, 0, 1, 1, 1], 
 [1, 1, 0, 0, 0],
 [0, 1, 0, 0, 1],
 [0, 1, 0, 1, 0]
]
```

隣接行列はグラフ構造を二次元配列で表現し、繋がっているか否かを0,1で表します。例えば、1行目の配列は頂点1が2,3と繋がっていることを表します。テストケースの隣接行列を作成したら、隣接行列を頂点ごとにループで回し、自分自身より小さい頂点を繋がっている線をカウントします。それがちょうど一つだけ存在する場合にカウントし、結果を出力します。

隣接リストを用いた方法
```py:
# 入力
M, N = map(int, input().split())

# 隣接リストの初期化
adjacency_list = [[] for _ in range(M)]

for i in range(N):
    a, b = map(int,input().split())
    adjacency_list[a-1].append(b)
    adjacency_list[b-1].append(a)

count = 0
for i in range(M):
    smaller_neighbors = 0
    for j in adjacency_list[i]:
        if j < i+1:
            smaller_neighbors += 1
    if smaller_neighbors == 1:
        count += 1

print(count)
```

```py:隣接リスト
[[2, 3], [1, 3, 5, 4], [1, 2], [2, 5], [2, 4]]
```

隣接リストもグラフ構造を二次元配列で表現し、インデックスを頂点をみなして繋がっている頂点を配列として持ちます。例えば、1つ目の要素=頂点1は、2,3の頂点と繋がっていることを表します。テストケースの隣接リストを作成したら、隣接リストをループで回し、各頂点自分自身より小さい頂点を繋がっている線をカウントします。それがちょうど一つだけ存在する場合にカウントし、結果を出力します。

この問題でグラフ構造の2種類の表現方法を学びました。それぞれには特徴があります。計算量を考えると、隣接行列はO(N^2)、隣接リストはO(N+M)となるので隣接リストの方が効率的となります。しかし、隣接行列はできることの幅が広い表現形式です。例えば、線にコストが発生するような情報(電車の運賃など)を扱いたい場合、任意の数字を各マスに置くことで表現することができます。これを特に距離行列を言ったりします。また、行列形式なので色々な数学演算が可能となります。

</details>